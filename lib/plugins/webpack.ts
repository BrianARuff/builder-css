// Note: This file requires webpack types to be installed in the consuming project
// Simple basename implementation to avoid path dependency
function basename(filePath: string): string {
  return filePath.split(/[\\/]/).pop() || filePath
}

// Define minimal types to avoid requiring webpack as a dependency
interface Compiler {
  hooks: any
  webpack: any
}

interface WebpackPluginInstance {
  apply(compiler: Compiler): void
}

interface ZeroCSSWebpackPluginOptions {
  outputFile?: string
  minify?: boolean
  test?: RegExp
}

interface ExtractedStyle {
  id: string
  cssText: string
  sourceFile: string
}

export class ZeroCSSWebpackPlugin implements WebpackPluginInstance {
  private options: ZeroCSSWebpackPluginOptions
  private extractedStyles = new Map<string, ExtractedStyle>()
  
  constructor(options: ZeroCSSWebpackPluginOptions = {}) {
    this.options = {
      outputFile: 'zero-css.css',
      minify: false,
      test: /\.(ts|tsx|js|jsx)$/,
      ...options
    }
  }
  
  apply(compiler: Compiler) {
    const pluginName = 'ZeroCSSWebpackPlugin'
    
    compiler.hooks.compilation.tap(pluginName, (compilation: any) => {
      // Hook into the module processing
      compilation.hooks.buildModule.tap(pluginName, (module: any) => {
        if (this.shouldProcessModule(module)) {
          this.processModule(module)
        }
      })
      
      // Generate CSS file during asset processing
      compilation.hooks.processAssets.tap(
        {
          name: pluginName,
          stage: compiler.webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL
        },
        () => {
          if (this.extractedStyles.size > 0) {
            const cssContent = this.generateCSSContent()
            compilation.emitAsset(this.options.outputFile!, {
              source: () => cssContent,
              size: () => cssContent.length
            })
          }
        }
      )
    })
    
    // Clear styles at the start of each compilation
    compiler.hooks.beforeRun.tap(pluginName, () => {
      this.extractedStyles.clear()
    })
    
    compiler.hooks.watchRun.tap(pluginName, () => {
      this.extractedStyles.clear()
    })
  }
  
  private shouldProcessModule(module: any): boolean {
    if (!module.resource) return false
    return this.options.test!.test(module.resource)
  }
  
  private processModule(module: any) {
    // In a real implementation, you would parse the module source
    // and extract css() calls using a proper AST parser
    
    // This is a simplified placeholder
    const source = module.originalSource?.()?.source()
    if (typeof source === 'string') {
      const styles = this.extractStylesFromSource(source, module.resource)
      styles.forEach(style => {
        this.extractedStyles.set(style.id, style)
      })
    }
  }
  
  private extractStylesFromSource(source: string, filename: string): ExtractedStyle[] {
    const styles: ExtractedStyle[] = []
    
    // Simplified regex-based extraction (same as Vite plugin)
    const cssCallRegex = /css\s*\(\s*({[\s\S]*?})\s*\)/g
    const templateLiteralRegex = /css\s*`([\s\S]*?)`/g
    
    let match
    let counter = 0
    
    // Extract object-based styles
    while ((match = cssCallRegex.exec(source)) !== null) {
      const styleObject = match[1]
      const id = `${basename(filename)}-${counter++}`
      
      styles.push({
        id,
        cssText: `/* Object style from ${filename} */\n${styleObject}`,
        sourceFile: filename
      })
    }
    
    // Extract template literal styles
    while ((match = templateLiteralRegex.exec(source)) !== null) {
      const cssText = match[1]
      const id = `${basename(filename)}-${counter++}`
      
      styles.push({
        id,
        cssText: cssText.trim(),
        sourceFile: filename
      })
    }
    
    return styles
  }
  
  private generateCSSContent(): string {
    const cssRules = Array.from(this.extractedStyles.values())
      .map(style => style.cssText)
      .join(this.options.minify ? '' : '\n\n')
    
    if (this.options.minify) {
      return cssRules.replace(/\s+/g, ' ').trim()
    }
    
    return `/* Generated by zero-css */\n${cssRules}`
  }
}