import type { Plugin } from 'vite'
import { createFilter } from 'vite'

interface ZeroCSSPluginOptions {
  include?: string | RegExp | Array<string | RegExp>
  exclude?: string | RegExp | Array<string | RegExp>
  outputFile?: string
  minify?: boolean
}

interface ExtractedStyle {
  id: string
  cssText: string
  sourceFile: string
  line?: number
}

export function zeroCSSPlugin(options: ZeroCSSPluginOptions = {}): Plugin {
  const filter = createFilter(
    options.include || /\.(ts|tsx|js|jsx)$/,
    options.exclude || /node_modules/
  )
  
  const extractedStyles = new Map<string, ExtractedStyle>()
  const outputFile = options.outputFile || 'zero-css.css'
  
  return {
    name: 'zero-css',
    
    buildStart() {
      // Clear extracted styles at the start of each build
      extractedStyles.clear()
    },
    
    transform(code: string, id: string) {
      if (!filter(id)) return null
      
      // Set build-time environment variable
      const transformedCode = code.replace(
        /process\.env\.NODE_ENV/g,
        `"${process?.env?.NODE_ENV || 'production'}"`
      ).replace(
        /process\.env\.ZERO_CSS_BUILD_TIME/g,
        '"true"'
      )
      
      return {
        code: transformedCode,
        map: null
      }
    },
    
    generateBundle() {
      if (extractedStyles.size === 0) return
      
      // Generate optimized CSS file
      const cssContent = generateCSSFile(extractedStyles, options.minify)
      
      this.emitFile({
        type: 'asset',
        fileName: outputFile,
        source: cssContent
      })
    }
  }
}

function generateCSSFile(
  styles: Map<string, ExtractedStyle>, 
  minify = false
): string {
  const cssRules = Array.from(styles.values())
    .map(style => style.cssText)
    .join(minify ? '' : '\n\n')
  
  if (minify) {
    return cssRules.replace(/\s+/g, ' ').trim()
  }
  
  return `/* Generated by zero-css */\n${cssRules}`
}

// Additional utility for extracting styles from AST (simplified version)
export function extractStylesFromCode(code: string, filename: string): ExtractedStyle[] {
  const styles: ExtractedStyle[] = []
  
  // This is a simplified regex-based extraction
  // In a real implementation, you'd want to use a proper AST parser
  const cssCallRegex = /css\s*\(\s*({[\s\S]*?})\s*\)/g
  const templateLiteralRegex = /css\s*`([\s\S]*?)`/g
  
  let match
  let counter = 0
  
  // Extract object-based styles
  while ((match = cssCallRegex.exec(code)) !== null) {
    const styleObject = match[1]
    const id = `${filename}-${counter++}`
    
    styles.push({
      id,
      cssText: `/* Object style from ${filename} */\n${styleObject}`,
      sourceFile: filename
    })
  }
  
  // Extract template literal styles
  while ((match = templateLiteralRegex.exec(code)) !== null) {
    const cssText = match[1]
    const id = `${filename}-${counter++}`
    
    styles.push({
      id,
      cssText: cssText.trim(),
      sourceFile: filename
    })
  }
  
  return styles
}